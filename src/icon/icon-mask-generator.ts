/**
 * Icon Mask Generator - SCSS Mask Icon Utilities Generator for NPM package
 * @fileoverview Generates SCSS utilities for mask-based icons with currentColor support
 */

import * as fs from "fs";
import * as path from "path";
import { optimize, type Config as OptimizeOptions } from "svgo";
import {
  DEFAULT_ICON_SOURCE_DIR,
  DEFAULT_OPTIMIZED_ICON_DIR,
  DEFAULT_SCSS_OUTPUT_PATH,
  CACHE_FILE_PATH,
} from "./constants.js";

/**
 * Configuration for icon mask generation
 */
export interface MaskGeneratorConfig {
  /** Path to SVG icons directory */
  iconDir: string;
  /** Output directory for optimized SVG files */
  optimizedIconDir: string;
  /** Output path for generated SCSS file */
  outputPath: string;
  /** Whether to include before/after pseudo-element variants */
  includePseudoElements: boolean;
  /** Whether to optimize SVG with svgo (default: true) */
  optimizeSvg?: boolean;
  /** Custom svgo configuration (optional) */
  svgoConfig?: OptimizeOptions;
}

/**
 * Default configuration
 */
const DEFAULT_CONFIG: MaskGeneratorConfig = {
  iconDir: DEFAULT_ICON_SOURCE_DIR,
  optimizedIconDir: DEFAULT_OPTIMIZED_ICON_DIR,
  outputPath: DEFAULT_SCSS_OUTPUT_PATH,
  includePseudoElements: true,
  optimizeSvg: true,
};

/**
 * Icon data structure for SCSS generation
 */
interface IconData {
  name: string;
  base64: string;
  optimizedSvg: string;
}

/**
 * Optimize SVG content using svgo
 */
function optimizeSvgContent(
  svgContent: string,
  svgoConfig?: OptimizeOptions
): string {
  try {
    const result = optimize(svgContent, svgoConfig);
    return result.data;
  } catch (error) {
    console.warn(`‚ö†Ô∏è  SVG optimization failed, using original content: ${error}`);
    return svgContent;
  }
}

/**
 * Convert SVG content to base64 data URL
 */
function svgToBase64(svgContent: string, shouldOptimize: boolean = true, svgoConfig?: OptimizeOptions): string {
  let processedSvg = svgContent;

  // Optimize SVG if enabled
  if (shouldOptimize) {
    processedSvg = optimizeSvgContent(processedSvg, svgoConfig);
  }

  // Clean the SVG content - remove XML declarations and comments
  const cleanedSvg = processedSvg
    .replace(/<\?xml[^>]*>/g, "")
    .replace(/<!--[\s\S]*?-->/g, "")
    .trim();

  // Encode to base64
  const base64 = Buffer.from(cleanedSvg, "utf8").toString("base64");
  return base64;
}

/**
 * Read and process all SVG files from the icon directory
 */
function loadIconData(
  iconDir: string,
  optimizeSvg: boolean = true,
  svgoConfig?: OptimizeOptions
): IconData[] {
  const iconData: IconData[] = [];

  try {
    if (!fs.existsSync(iconDir)) {
      throw new Error(`Icon directory does not exist: ${iconDir}`);
    }

    const files = fs.readdirSync(iconDir);
    const svgFiles = files.filter((file) => file.endsWith(".svg"));

    for (const file of svgFiles) {
      const filePath = path.join(iconDir, file);
      const svgContent = fs.readFileSync(filePath, "utf8");
      const iconName = path.basename(file, ".svg");

      // Get optimized SVG content
      let processedSvg = svgContent;
      if (optimizeSvg) {
        processedSvg = optimizeSvgContent(svgContent, svgoConfig);
      }

      // Clean the SVG content
      const cleanedSvg = processedSvg
        .replace(/<\?xml[^>]*>/g, "")
        .replace(/<!--[\s\S]*?-->/g, "")
        .trim();

      iconData.push({
        name: iconName,
        base64: svgToBase64(svgContent, optimizeSvg, svgoConfig),
        optimizedSvg: cleanedSvg,
      });
    }

    console.log(`‚úÖ Loaded ${iconData.length} SVG icons from ${iconDir}`);
    if (optimizeSvg) {
      console.log(`üîß SVG optimization enabled`);
    }
    return iconData;
  } catch (error) {
    throw new Error(`Failed to load icons from ${iconDir}: ${String(error)}`);
  }
}

/**
 * Generate SCSS content with mixins and icon classes
 */
function generateScssContent(
  iconData: IconData[],
  includePseudoElements: boolean
): string {
  const timestamp = new Date().toISOString();
  const iconCount = iconData.length;

  // Create icon data map for SCSS
  const iconMapEntries = iconData
    .map((icon) => `  '${icon.name}': '${icon.base64}'`)
    .join(",\n");

  const scssContent = `// Auto-generated icon mask utilities
// Generated on: ${timestamp}
// Total icons: ${iconCount}
// Generated by @photosynthesic/nubui

// Base mixin for all mask icons
@mixin mask-icon-base {
  mask-size: contain;
  mask-repeat: no-repeat;
  mask-position: center;
  background-color: currentColor;
}

// Icon data map
$icon-masks: (
${iconMapEntries}
);

// Generate mask icon classes
@each $name, $data in $icon-masks {
  .mask-icon-#{$name} {
    @include mask-icon-base;
    mask-image: url("data:image/svg+xml;base64,#{$data}");
  }
}
${
  includePseudoElements
    ? `
// Generate pseudo-element variants for flexible usage
@each $name, $data in $icon-masks {
  .before\\:mask-icon-#{$name}::before {
    @include mask-icon-base;
    mask-image: url("data:image/svg+xml;base64,#{$data}");
    content: '';
    display: inline-block;
  }
  
  .after\\:mask-icon-#{$name}::after {
    @include mask-icon-base;
    mask-image: url("data:image/svg+xml;base64,#{$data}");
    content: '';
    display: inline-block;
  }
}
`
    : ""
}
// Usage examples:
// 
// Basic usage:
// <div class="mask-icon-heart-line w-6 h-6 text-blue-500"></div>
// 
// With pseudo-elements:
// <button class="after:mask-icon-arrow-right after:w-4 after:h-4 after:ml-2">
//   Next
// </button>
// 
// Color customization with currentColor:
// <span class="mask-icon-star-fill text-yellow-400 hover:text-yellow-500"></span>
`;

  return scssContent;
}

/**
 * Write generated SCSS content to file
 */
function writeScssFile(content: string, outputPath: string): void {
  try {
    // Ensure output directory exists
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write SCSS file
    fs.writeFileSync(outputPath, content, "utf8");
    console.log(`‚úÖ Generated SCSS file: ${outputPath}`);
  } catch (error) {
    throw new Error(
      `Failed to write SCSS file to ${outputPath}: ${String(error)}`
    );
  }
}

/**
 * Write optimized SVG files to format directory
 */
function writeOptimizedSvgs(iconData: IconData[], outputDir: string): void {
  try {
    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    let writtenCount = 0;
    for (const icon of iconData) {
      const outputPath = path.join(outputDir, `${icon.name}.svg`);
      fs.writeFileSync(outputPath, icon.optimizedSvg, "utf8");
      writtenCount++;
    }

    console.log(`‚úÖ Saved ${writtenCount} optimized SVG files to ${outputDir}`);
  } catch (error) {
    throw new Error(
      `Failed to write optimized SVG files to ${outputDir}: ${String(error)}`
    );
  }
}

/**
 * Write cache file with build configuration
 */
function writeCacheFile(config: MaskGeneratorConfig): void {
  try {
    const cacheData = {
      iconDir: config.iconDir,
      optimizedIconDir: config.optimizedIconDir,
      outputPath: config.outputPath,
      timestamp: new Date().toISOString(),
    };

    fs.writeFileSync(CACHE_FILE_PATH, JSON.stringify(cacheData, null, 2), "utf8");
    console.log(`‚úÖ Saved build configuration to ${CACHE_FILE_PATH}`);
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Failed to write cache file: ${String(error)}`);
    // Don't fail the entire build if cache write fails
  }
}

/**
 * Generate icon mask SCSS utilities
 */
export function generateIconMasks(
  config: Partial<MaskGeneratorConfig> = {}
): void {
  const finalConfig = { ...DEFAULT_CONFIG, ...config };

  // If optimizedIconDir is not explicitly provided, derive it from iconDir
  if (!config.optimizedIconDir) {
    const baseIconDir = config.iconDir || DEFAULT_ICON_SOURCE_DIR;
    finalConfig.optimizedIconDir = path.join(baseIconDir, "format");
  }

  console.log("üöÄ Starting icon mask generation...");
  console.log(`üìÅ Icon directory: ${finalConfig.iconDir}`);
  console.log(`üìÅ Optimized icon output: ${finalConfig.optimizedIconDir}`);
  console.log(`üìÑ SCSS output file: ${finalConfig.outputPath}`);
  console.log(
    `üîÑ Pseudo-elements: ${
      finalConfig.includePseudoElements ? "enabled" : "disabled"
    }`
  );
  console.log(
    `üîß SVG optimization: ${finalConfig.optimizeSvg ? "enabled" : "disabled"}`
  );

  try {
    // Load icon data
    const iconData = loadIconData(
      finalConfig.iconDir,
      finalConfig.optimizeSvg,
      finalConfig.svgoConfig
    );

    if (iconData.length === 0) {
      console.warn("‚ö†Ô∏è  No SVG files found in the icon directory");
      return;
    }

    // Write optimized SVG files
    writeOptimizedSvgs(iconData, finalConfig.optimizedIconDir);

    // Generate SCSS content
    const scssContent = generateScssContent(
      iconData,
      finalConfig.includePseudoElements
    );

    // Write SCSS file
    writeScssFile(scssContent, finalConfig.outputPath);

    console.log("‚ú® Icon mask generation completed successfully!");
    console.log(`üìä Generated ${iconData.length} icon mask utilities`);

    // Write cache file after all operations succeed
    writeCacheFile(finalConfig);
  } catch (error) {
    console.error(`‚ùå Icon mask generation failed: ${String(error)}`);
    process.exit(1);
  }
}
